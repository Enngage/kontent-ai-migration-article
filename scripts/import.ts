import {
  MigrationAsset,
  MigrationElementModels,
  MigrationElements,
  MigrationItem,
  elementsBuilder,
  importAsync,
  storeAsync,
} from "@kontent-ai-consulting/migration-toolkit";
import { readFileSync, readdirSync } from "fs";
import { parse } from "path";

/**
 * Optionally (but strongly recommended) you may define a migration model
 * representing the content type you are trying to migrate into
 */
interface MovieElements extends MigrationElements {
  title: MigrationElementModels.TextElement;
  plot: MigrationElementModels.RichTextElement;
  length: MigrationElementModels.NumberElement;
  category: MigrationElementModels.MultipleChoiceElement;
  poster: MigrationElementModels.AssetElement;
  released: MigrationElementModels.DateTimeElement;
  releasecategory: MigrationElementModels.TaxonomyElement;
  seoname: MigrationElementModels.UrlSlugElement;
  stars: MigrationElementModels.LinkedItemsElement;
}

interface SourceItemModel {
  title: string;
  language: string;
  genre: string;
  text: string;
  duration: number;
}

function toCodename(text: string): string {
  // Regular expression to match alphanumeric characters and underscores
  const regex = /[^a-zA-Z0-9_]/g;
  // Replace any character that doesn't match the regex with an empty string
  return text.replace(regex, "").toLowerCase();
}

function translateLanguageCodename(language: string): string {
  if (language === "english") {
    return "en";
  }
  throw Error(`Invalid language '${language}'`);
}

const fileData = readFileSync("./source-data.json").toString();
const migrationItems: MigrationItem[] = [];

for (const item of JSON.parse(fileData) as SourceItemModel[]) {
  const movie: MigrationItem<MovieElements> = {
    system: {
      name: item.title,
      codename: toCodename(item.title),
      collection: {
        codename: "default",
      },
      language: {
        codename: translateLanguageCodename(item.language),
      },
      type: {
        codename: "movie",
      },
      workflow: {
        codename: "default",
      },
      workflow_step: {
        codename: "published",
      },
    },
    elements: {
      title: elementsBuilder.textElement({ value: item.title }),
      length: elementsBuilder.numberElement({ value: item.duration }),
      category: elementsBuilder.multipleChoiceElement({
        value: item.genre.split(",").map((m) => {
          return { codename: m.trim() };
        }),
      }),
      poster: elementsBuilder.assetElement({
        value: [
          {
            codename: "warrior_teaser",
          },
        ],
      }),
      plot: elementsBuilder.richTextElement({
        value: {
          value: `<h1>${item.title}</h1><p>${item.text}</p>`,
          components: [],
        },
      }),
      releasecategory: elementsBuilder.taxonomyElement({
        value: [
          {
            codename: "global_release",
          },
        ],
      }),
      released: elementsBuilder.dateTimeElement({
        value: "2011-09-09T00:00:00Z",
      }),
      seoname: elementsBuilder.urlSlugElement({
        value: {
          mode: "autogenerated",
          value: "",
        },
      }),
      stars: elementsBuilder.linkedItemsElement({
        value: [
          {
            codename: "tom_hardy",
          },
        ],
      }),
    },
  };

  migrationItems.push(movie);
}

const scanDir = "files";
const migrationAssets: MigrationAsset[] = readdirSync(scanDir).map(
  (filename) => {
    return {
      binaryData: readFileSync(`${scanDir}\\${filename}`),
      codename: parse(filename).name,
      filename: filename,
      title: filename,
    };
  }
);

// stores data on FS for later use
await storeAsync({
  data: { assets: migrationAssets, items: migrationItems },
  filename: `data.zip`,
});

// and import to Kontent.ai
await importAsync({
  data: { assets: migrationAssets, items: migrationItems },
  environmentId: "91990386-ce1d-0129-beb7-9aa24657820f",
  apiKey: "",
  skipFailedItems: false,
});
